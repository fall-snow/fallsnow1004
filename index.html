<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ë§ˆí™”ì„¹ í”¼í•˜ê¸° â€” ì í”„ê°•í™”íŒ</title>
<style>
  :root{--bg1:#061127;--panel:rgba(255,255,255,0.04);--text:#e9f6ff}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),#04101a);font-family:Inter,"Noto Sans KR",system-ui,-apple-system,sans-serif;color:var(--text)}
  .wrap{display:flex;flex-direction:column;height:100vh;padding:12px;box-sizing:border-box;gap:10px}
  .panel{background:var(--panel);padding:10px;border-radius:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .note{font-size:12px;color:#cde9ff;opacity:.95}
  #gamebox{position:relative;flex:1;border-radius:12px;overflow:hidden;box-shadow:0 18px 40px rgba(0,0,0,0.6)}
  canvas{display:block;width:100%;height:100%}
  .preview img{max-height:64px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)}
  button,select{background:linear-gradient(90deg,#7c3aed,#ec4899);border:none;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  select{background:transparent;color:var(--text);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06)}
  footer{font-size:12px;color:#9bb7e6;text-align:center;padding:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="note">ë£¨íŠ¸ì— <strong>cibung.jpg</strong> (ì¥ì• ë¬¼) ì™€ <strong>koyam.jpg</strong> (ìºë¦­í„°)ë¥¼ ë„£ìœ¼ì„¸ìš”.</div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <select id="difficulty">
        <option value="easy">ì‰¬ì›€</option>
        <option value="normal" selected>ë³´í†µ</option>
        <option value="hard">ì–´ë ¤ì›€</option>
      </select>
      <button id="startBtn" disabled>Start</button>
      <button id="retryBtn" disabled>Retry</button>
      <button id="muteBtn">ğŸ”Š</button>
    </div>
    <div style="margin-left:12px;color:#cfe8ff">ì ìˆ˜: <strong id="score">0</strong> &nbsp; ìµœê³ : <strong id="best">0</strong></div>
  </div>

  <div id="gamebox">
    <canvas id="game"></canvas>

    <div style="position:absolute;left:12px;top:12px;display:flex;gap:12px;align-items:center">
      <div class="preview"><div style="font-size:12px;color:#d9f0ff">ì¥ì• ë¬¼</div><img id="previewObs" src="cibung.jpg" alt="obs"></div>
      <div class="preview"><div style="font-size:12px;color:#d9f0ff">ìºë¦­í„°</div><img id="previewPl" src="koyam.jpg" alt="pl"></div>
    </div>

    <div style="position:absolute;right:12px;top:12px;display:flex;flex-direction:column;gap:8px;align-items:flex-end">
      <div class="note">ìš”ì²­ ë°˜ì˜: ìºë¦­í„° ì‘ê²Œ, ì¥ì• ë¬¼ ë” í¬ê²Œ(ë¹„ìœ¨ ìœ ì§€), ê°„ê²© í¬ê²Œ, ì í”„ ê°•í•˜ê²Œ â€” í™”ë©´ì„ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ìë™ ìº¡.</div>
    </div>
  </div>

  <footer>ë¹„ìœ¨ì€ ê·¸ëŒ€ë¡œ â€” í¬ê¸°ì™€ ì í”„/ê°„ê²©ì„ ìˆ˜í•™ì ìœ¼ë¡œ ë³´ì •í–ˆìŠµë‹ˆë‹¤.</footer>
</div>

<script>
/* ì í”„ ê°•í™”íŒ â€” ìë™ ë¡œë“œ: cibung.jpg / koyam.jpg
   ìš”ì•½:
   - ìºë¦­í„° í¬ê¸°ë¥¼ ì¤„ì—¬(í­ ê°ì†Œ) í”¼í•˜ê¸° ì‰¬ì›€.
   - ì¥ì• ë¬¼ì„ ë” í¬ê²Œ (ë¹„ìœ¨ ìœ ì§€) ì‹œë„í•˜ë˜, í”Œë ˆì´ì–´ê°€ ì‹¤ì œë¡œ ì í”„í•´ì„œ ë„˜ì„ ìˆ˜ ìˆë„ë¡
     ìë™ìœ¼ë¡œ 'í—ˆìš© ìµœëŒ€ í¬ê¸°'ë¥¼ ê³„ì‚°/ì¡°ì •í•¨.
   - JUMP_V0ëŠ” sqrt(2*g*requiredRise)*boostë¡œ ê³„ì‚°í•˜ê³ , apexê°€ í™”ë©´ ìœ„ë¡œ ë‚˜ê°€ë©´ ìº¡.
   - spawn ê°„ê²©ì„ airtimeê³¼ worldSpeed ê¸°ë°˜ìœ¼ë¡œ ë„‰ë„‰í•˜ê²Œ ì„¤ì •.
*/

/* ---- ê¸°ë³¸ ì…‹ì—… ---- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d',{alpha:true});
let DPR = window.devicePixelRatio || 1;
function resizeCanvas(){
  const r = canvas.getBoundingClientRect();
  canvas.width = Math.max(900, Math.floor(r.width * DPR));
  canvas.height = Math.max(420, Math.floor(r.height * DPR));
}
window.addEventListener('resize', ()=>{ DPR = window.devicePixelRatio || 1; resizeCanvas(); });
resizeCanvas();

/* UI */
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const muteBtn = document.getElementById('muteBtn');
const difficultyEl = document.getElementById('difficulty');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');

/* ì›ë³¸ ë¹„ìœ¨(ê³ ì •) */
const PLAYER_R_W = 143, PLAYER_R_H = 54;
const OB_R_W = 720, OB_R_H = 934;

/* ì´ë¯¸ì§€ */
let obsImg = new Image();
let plImg = new Image();
let obsLoaded=false, plLoaded=false;
obsImg.onload = ()=>{ obsLoaded=true; checkReady(); drawIdle(); };
obsImg.onerror = ()=>{ obsLoaded=false; alert('cibung.jpg ë¡œë“œ ì‹¤íŒ¨: ë£¨íŠ¸ì— ì—…ë¡œë“œí–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.'); };
plImg.onload = ()=>{ plLoaded=true; checkReady(); drawIdle(); };
plImg.onerror = ()=>{ plLoaded=false; alert('koyam.jpg ë¡œë“œ ì‹¤íŒ¨: ë£¨íŠ¸ì— ì—…ë¡œë“œí–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.'); };
obsImg.src = 'cibung.jpg';
plImg.src = 'koyam.jpg';

/* ê²Œì„ ìƒíƒœ */
let gameRunning=false;
let score = 0;
let best = Number(localStorage.getItem('mahwa_best_github')||0);
bestEl.textContent = best;

let player = {x:0,y:0,w:0,h:0,vy:0,onGround:true};
let obstacles = [];
let lastSpawn = 0;
let timeStart = 0;

/* ë¬¼ë¦¬ íŒŒë¼ë¯¸í„° (ë™ì  ê³„ì‚°) */
let GRAVITY = 2200;     // px/s^2 (scaled)
let JUMP_V0 = -700;     // px/s (ìŒìˆ˜: ìœ„)
let safetyMargin = 12;  // px
let allowedObstacleH = 120; // ì‹¤ì œ ìŠ¤í°ë˜ëŠ” ì¥ì• ë¬¼ ë†’ì´ (ë™ì )
let jumpBoost = 1.35;   // ì‚¬ìš©ìê°€ ì›í•œ 'ë” ì í”„ê° ìˆê²Œ' ê³„ìˆ˜
const topMargin = 20;   // í”Œë ˆì´ì–´ ìµœê³ ì ì´ ì´ í”½ì…€ë³´ë‹¤ ìœ„ë¡œ ì•ˆ ë‚˜ê°€ê²Œ

/* ì‚¬ìš´ë“œ */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let muted=false;
function playTone(freq=440, dur=0.08, type='sine', gain=0.08){ if(muted) return; try{ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur);}catch(e){} }
muteBtn.addEventListener('click', ()=>{ muted = !muted; muteBtn.textContent = muted? 'ğŸ”ˆ':'ğŸ”Š'; });

/* --- í¬ê¸° ê³„ì‚°(ìš”êµ¬: ìºë¦­í„°ëŠ” ì‘ê²Œ, ì¥ì• ë¬¼ì€ í¬ê²Œ ì‹œë„) --- */
function computeBaseSizes(){
  const H = canvas.height;
  // ì‚¬ìš©ì ìš”ì²­ ë°˜ì˜:
  // - ìºë¦­í„°ë¥¼ ì‘ê²Œ: canvas ë†’ì´ì˜ 10% (ê¸°ë³¸ë³´ë‹¤ ì‘ìŒ)
  // - ì¥ì• ë¬¼ì„ ë” í‚¤ì›€: canvas ë†’ì´ì˜ 20% (ê¸°ë³¸ë³´ë‹¤ í¼)
  const playerTargetH = Math.max(32, Math.min(180, Math.round(H * 0.10))); // ì‘ê²Œ
  const obstacleTargetH = Math.max(64, Math.min(Math.round(H * 0.30), Math.round(H * 0.20))); // ë” í¼, ìº¡ í¬í•¨
  const playerW = Math.round(playerTargetH * (PLAYER_R_W / PLAYER_R_H));
  const obstacleW = Math.round(obstacleTargetH * (OB_R_W / OB_R_H));
  return { playerW, playerH:playerTargetH, obstacleW, obstacleH:obstacleTargetH };
}

/* --- ë¬¼ë¦¬ ê³„ì‚°: ì¥ì• ë¬¼ ë†’ì´ì™€ ì í”„ì†ë„(JUMP_V0) ì¡°ìœ¨ --- */
function computePhysicsAndLimits(){
  // ë¨¼ì € ê¸°ë³¸ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
  const sizes = computeBaseSizes();
  // safety margin: ì¥ì• ë¬¼ ë†’ì´ì˜ 10~12% ë˜ëŠ” ìµœì†Œ 12px
  safetyMargin = Math.max(12, Math.round(sizes.obstacleH * 0.12));

  // gravityëŠ” ìº”ë²„ìŠ¤ í¬ê¸°ì— ë¹„ë¡€í•´ ìŠ¤ì¼€ì¼ (ë¹ ë¥´ê³  íŒíŒ íŠ€ëŠ” ëŠë‚Œ)
  const baseCanvas = 640;
  GRAVITY = 2400 * (canvas.height / baseCanvas);

  // desired obstacle height
  let desiredObH = sizes.obstacleH;

  // We will compute maximum rise allowed so player top won't go above topMargin
  // but first set player.y (we should have player.h from resetState already)
  const groundH = Math.floor(canvas.height * 0.06);
  const playerBottom = canvas.height - groundH; // y of bottom line
  const playerTopInitial = playerBottom - player.h; // player.y
  const maxRiseAllowed = playerTopInitial - topMargin; // how much the top can move upward

  // required rise to clear obstacle: obstacle height + margin
  let requiredRise = desiredObH + safetyMargin;

  // If requiredRise > maxRiseAllowed, we cannot allow obstacle that big: reduce obstacle height
  if(requiredRise > maxRiseAllowed){
    // reduce obstacle so it becomes just jumpable with margin
    const allowedH = Math.max(32, Math.floor(maxRiseAllowed - safetyMargin));
    desiredObH = allowedH;
    requiredRise = desiredObH + safetyMargin;
    // small visual note: obstacle reduced to fit jump cap
  }

  // compute base jump speed for requiredRise
  let baseV0 = Math.sqrt(2 * GRAVITY * requiredRise);
  // apply user-requested jumpBoost to make it more 'jumpy'
  baseV0 = baseV0 * jumpBoost;

  // cap apex so it doesn't go above topMargin:
  const maxRisePossible = maxRiseAllowed;
  const apexIfBoosted = (baseV0 * baseV0) / (2 * GRAVITY);
  if(apexIfBoosted > maxRisePossible){
    // cap baseV0 so apex = maxRisePossible
    baseV0 = Math.sqrt(2 * GRAVITY * maxRisePossible);
  }

  // final negative v0 (upwards)
  JUMP_V0 = - Math.ceil(baseV0);

  // compute airtime (time until player returns to initial vertical level)
  const airtime = 2 * Math.abs(JUMP_V0) / GRAVITY;

  // store allowed obstacle height for actual spawn
  allowedObstacleH = desiredObH;

  // return computed values for debug/use
  return { GRAVITY, JUMP_V0, safetyMargin, allowedObstacleH, airtime, maxRiseAllowed };
}

/* --- ìŠ¤í° ë° ì¶©ëŒ ìœ í‹¸ --- */
function spawnObstacle(worldSpeed){
  // use allowedObstacleH (already computed in resetState)
  const obH = allowedObstacleH;
  const obW = Math.round(obH * (OB_R_W / OB_R_H));
  const x = canvas.width + 10 + Math.random() * 160;
  const y = canvas.height - obH - Math.floor(canvas.height * 0.06);
  obstacles.push({x, y, w: obW, h: obH, passed: false});
}

function rectsCollide(a,b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

/* --- ì…ë ¥ & ì œì–´ --- */
function jump(){
  if(!gameRunning) return;
  if(player.onGround){
    player.vy = JUMP_V0;
    player.onGround = false;
    playTone(720,0.12,'sine',0.12);
  }
}
window.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); jump(); }});
canvas.addEventListener('mousedown', ()=>jump());
canvas.addEventListener('touchstart', ()=>{ jump(); }, {passive:true});

/* ë‚œì´ë„ ì˜í–¥ ê³„ìˆ˜ (ì›”ë“œ ì†ë„ì— ë°˜ì˜) */
function difficultyMultiplier(d){
  if(d === 'easy') return 0.85;
  if(d === 'normal') return 1.0;
  return 1.25;
}

/* --- ë¦¬ì…‹/ì‹œì‘/ì¢…ë£Œ --- */
function resetState(){
  resizeCanvas();
  const sizes = computeBaseSizes();
  // apply player size (ì‘ê²Œ)
  player.w = sizes.playerW;
  player.h = sizes.playerH;
  player.x = Math.round(canvas.width * 0.12);
  player.y = canvas.height - player.h - Math.floor(canvas.height * 0.06);
  player.vy = 0; player.onGround = true;

  // compute physics & allowed obstacle height (and jump speed)
  const phys = computePhysicsAndLimits();

  // reset obstacles and timers
  obstacles = [];
  lastSpawn = performance.now();
  timeStart = performance.now();
  score = 0;
  scoreEl.textContent = score;
}

/* start/end */
function startGame(){
  if(!obsLoaded || !plLoaded){
    alert('ì´ë¯¸ì§€ë¥¼ ë¨¼ì € ì—…ë¡œë“œí•˜ê³  í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš” (cibung.jpg / koyam.jpg).');
    return;
  }
  if(audioCtx.state === 'suspended') audioCtx.resume();
  resetState();
  prevTime = performance.now();
  spawnAccumulator = 0;
  gameRunning = true;
  startBtn.disabled = true;
  retryBtn.disabled = true;
  playTone(880,0.12,'triangle',0.08);
  requestAnimationFrame(loop);
}

function endGame(){
  gameRunning = false;
  retryBtn.disabled = false;
  startBtn.disabled = false;
  playTone(150,0.35,'sawtooth',0.18);
  if(score > best){ best = score; localStorage.setItem('mahwa_best_github', best); bestEl.textContent = best; }
}

/* --- ë©”ì¸ ë£¨í”„ --- */
let prevTime = 0;
let spawnAccumulator = 0;
function loop(now){
  if(!gameRunning) return;
  const dtMs = Math.min(40, now - prevTime);
  const dt = dtMs / 1000;
  prevTime = now;

  // world speed increases over time (but difficulty affects multiplier)
  const timeFactor = Math.min(3.5, 1 + (now - timeStart)/60000);
  const diff = difficultyEl.value;
  const diffMult = difficultyMultiplier(diff);
  const worldSpeed = 260 * diffMult * timeFactor; // px/s

  // compute current physics values (ensure if resized mid-game we keep consistent)
  const phys = computePhysicsAndLimits();
  const airtime = 2 * Math.abs(JUMP_V0) / GRAVITY;

  // adaptive spawn interval: ensure spacing >> player's horizontal travel during airtime
  const desiredSpacingPx = Math.max(canvas.width * 0.6, worldSpeed * airtime * 1.05 + Math.round(allowedObstacleH * (OB_R_W/OB_R_H)) * 1.6);
  const spawnIntervalNowMs = Math.max(600, desiredSpacingPx / worldSpeed * 1000);

  spawnAccumulator += dtMs;
  if(spawnAccumulator >= spawnIntervalNowMs){
    spawnAccumulator = 0;
    spawnObstacle(worldSpeed);
  }

  // physics: integrate player
  player.vy += GRAVITY * dt;
  player.y += player.vy * dt;
  const groundY = canvas.height - Math.floor(canvas.height * 0.06);
  if(player.y + player.h >= groundY){
    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // move obstacles
  for(let i=obstacles.length-1;i>=0;i--){
    obstacles[i].x -= worldSpeed * dt;
    if(obstacles[i].x + obstacles[i].w < -200) obstacles.splice(i,1);
  }

  // collisions & scoring
  for(const ob of obstacles){
    if(!ob.passed && ob.x + ob.w < player.x){
      ob.passed = true;
      score += 10;
      playTone(880 + Math.random()*220,0.09,'triangle',0.06);
    }
    const pBox = {x:player.x, y:player.y, w:player.w, h:player.h};
    const oBox = {x:ob.x, y:ob.y, w:ob.w, h:ob.h};
    if(rectsCollide(pBox, oBox)){
      endGame();
      return;
    }
  }

  // time-based score
  score += Math.floor(dt * 10 * timeFactor);
  scoreEl.textContent = score;

  // draw
  draw(now, worldSpeed, timeFactor);
  requestAnimationFrame(loop);
}

/* --- ê·¸ë¦¬ê¸° --- */
function draw(now, worldSpeed, timeFactor){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // bg
  const g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#071426'); g.addColorStop(1,'#03091a');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  // parallax blobs
  for(let i=0;i<6;i++){
    const t = now/1000;
    const depth = 1 - i*0.12;
    const x = (Math.sin(t*0.35 + i)*0.5 + 0.5) * canvas.width;
    const y = (Math.cos(t*0.5 + i)*0.4 + 0.5) * canvas.height * 0.7;
    const r = 60 + i*10;
    ctx.beginPath();
    ctx.fillStyle = `hsla(${(60+i*30)%360},70%,${30+i*4}%,${0.06+i*0.02})`;
    ctx.ellipse(x, y + i*6, r*depth, r*0.6*depth, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ground
  const groundH = Math.floor(canvas.height * 0.06);
  ctx.fillStyle = 'rgba(0,0,0,0.32)';
  ctx.fillRect(0, canvas.height - groundH, canvas.width, groundH);

  // obstacles
  for(const ob of obstacles){
    if(obsLoaded){
      try{ ctx.drawImage(obsImg, ob.x, ob.y, ob.w, ob.h); }
      catch(e){ ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h); }
      ctx.fillStyle='rgba(0,0,0,0.25)';
      ctx.beginPath(); ctx.ellipse(ob.x + ob.w*0.5, ob.y + ob.h + 8, ob.w*0.45, 10, 0,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    }
  }

  // player (bob)
  const bob = player.onGround ? Math.sin(now/180)*1.6 : 0;
  if(plLoaded){
    try{ ctx.drawImage(plImg, player.x, player.y + bob, player.w, player.h); }
    catch(e){ ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(player.x, player.y + bob, player.w, player.h); }
  } else {
    ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(player.x, player.y + bob, player.w, player.h);
  }

  // HUD
  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.03)';
  ctx.fillRect(12*DPR,12*DPR,280*DPR,46*DPR);
  ctx.fillStyle = '#dff0ff';
  ctx.font = `${14*DPR}px sans-serif`;
  ctx.fillText('ì ìˆ˜: ' + score, 22*DPR, 36*DPR);
  ctx.fillText('ìµœê³ : ' + best, 140*DPR, 36*DPR);
  ctx.restore();
}

/* idle preview */
function drawIdle(){
  resizeCanvas();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#071228'); g.addColorStop(1,'#04101a');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  const sizes = computeBaseSizes();
  const obW = sizes.obstacleW, obH = sizes.obstacleH;
  const obX = canvas.width*0.06, obY = canvas.height*0.11 + (canvas.height*0.78 - obH)/2;
  if(obsLoaded){ try{ ctx.drawImage(obsImg, obX, obY, obW, obH); }catch(e){ ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(obX, obY, obW, obH); } }
  else { ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(obX, obY, obW, obH); }

  const pW = sizes.playerW, pH = sizes.playerH;
  const pX = canvas.width*0.72, pY = canvas.height*0.46 - pH*0.5;
  if(plLoaded){ try{ ctx.drawImage(plImg, pX + (canvas.width*0.18 - pW)/2, pY + (canvas.height*0.18 - pH)/2, pW, pH); }catch(e){ ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(pX, pY, pW, pH); } }
  else { ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(pX, pY, pW, pH); }
}

/* readiness & UI wiring */
function checkReady(){
  if(obsLoaded && plLoaded){
    startBtn.disabled = false;
    retryBtn.disabled = true;
    resetState();
  }
}
startBtn.addEventListener('click', ()=>{ if(audioCtx.state === 'suspended') audioCtx.resume(); startGame(); });
retryBtn.addEventListener('click', ()=>{ resetState(); startGame(); });

/* init */
(function init(){
  // attempt auto-load (obsImg.src & plImg.src set above)
  function idleLoop(){ if(!gameRunning) drawIdle(); requestAnimationFrame(idleLoop); }
  idleLoop();
})();
</script>
</body>
</html>
